---"Forum"---


![image](https://github.com/Aleksandr-Khokhrin/MyForumApp_react-front/assets/147053338/539b78e8-1101-4244-a7cf-6e9b557bcc4c)


Ссылка на проект: https://itransition-diplom-forum-react-dce6a50e03e7.herokuapp.com/

Внимание! Страница может грузиться около минуты из-за того, что сервер Heroku спит. Почитайте пока описание)

Краткое описание инструментария:
Это первый мой проект с использованием ReactJS, NodeJS, MongoDB, Heroku. 
Дизайна проекта небыло, так что делал все на глаз с использованием MaterialUI. Основная задача была попрактиковаться с логикой react-приложения.
Для досижения максимального результата в понимании взаимосвязи Backend с Frontend решил также собрать и развернуть сервер на NodeJS с использованием MongoDB.
Хочу отметить, что все писал сам и понимаю как работает каждый скрипт в моём приложении. 

Основная идея:
Создать приложение/форум для создания, редактирования и оценки рецензий на игровую, книжную и кинематографическую тематику. 

Функционал:
1. Авторизация/регистрация пользователей с сопутствующей валидацией вводимых данных на backend с помощью mongoose.Schema(валидация работает и для создания рецензии). 
Пользователь при авторизации заполняет поля, потом, если поля заполнены, то данные отправляются на backend(с помощью useForm и redux-toolkit). Если все правильно, то на клиентскую часть приходит success (добавляю токен в localstorage, для того, чтобы при обновлении страницы пользователь все так-же был авторизирован). Ежели нет, то приходит ошибка с дополнениями. 
2. Просмотр рецензий осуществляется на главной странице под названием MainPage. Также осуществляется рендеринг рецензий по категориям(фильмы, книги, игры). 
Рендеринг по категориям осуществляется с помощью просеивания всех рецензий через фильтр. С течением времени понял, что это не есть хорошо. Для оптимальной работы приложения необходимо запрашивать у сервера необходимое количество определённых объектов для рендеринга (с вытекающим созданием пагинации на перспективу). Для запросов использовал redux, redux-toolkit, axios. 
3. По аналогичному сценарию также в приложении доступна функция просмотра одной рецензии. При клику на название открывается компонент за данными об одной статье. 
тут я использовал Redux-router(для логистики в приложении) и useParams(для передачи id в компонент с отображением выбранного объекта).
4. Создать рецензию можно через личный кабинет. При создании заполняются текстовые поля, подгружается картинка(отправляется на сервер и вместо неё приходит ссылка на изображение) через метод post.
    app.post('/upload', checkAuth, upload.single('image'), (req, res) =>{
        res.json({
            url: `uploads/${req.file.originalname}`,
        })
    });
Картинки я оставлял на backend, так как решил не заморачиваться, так как основной упор был на frontend части приложения. Теоретический картинки я бы хранил на Google Cloud или Amazon S3.
5. Также в приложении можно редактировать уже созданные рецензии и удалять их. Доступ есть только у автора рецензии.
6. В личном кабинете можно отредактировать свой профиль(поменять пароль и логин, а также изображение).
В профиле изображение устанавливается по дефолту, путём ставки в input прямой ссылки на картинку, а не подгрузки файла, как в создании рецензии.
7. Пользователи в приложении могут ставить лайки. Для того, чтобы считать колличество лайков я просто пушил id пользователей в массив с лайками и при клике на лайк у пользователя добавлял его в массив или удалял из него, если пользователь кликает уже по активному лайку. Тут для отслеживания событий я использовал useState и usEeffect.
8. Также в header приложения есть search по названиям с импользования filter.
9. В приложении есть смена языка интерфейса. Данная функция работает благодаря библиотеки i18next с использованием хука useTranslation по примеру ${t('hello')}. hello это ключ, у которого есть разные значения, соответствующие выбранному языку.
10. Также у каждой рецензии есть колличество просмотров и оценка автора. 

Инструментарий:
В создании клиентской части я использовал хуки/компоненты: 
- useState(для обновления состояния), 
- usEeffect(для отслеживания изменения в состояниях), 
- useParams(для передачи параметра ссылки/маршрута),
- useForm(для работы с формой),
- useRef(для значений, которые не нужно рендерить),  
- useDispatch(позволяет работать с Redux хранилищем), 
- useSelector(позволяет извлекать данные из Redux), 
- Navigate(для навигации при выполнении определённых алгоритмов), 
- Link(компонент для навигации при клике), 
- useTranslation(для работы со сменой языка), 
- Routes(для обозначения основной сетки Route), 
- Route(для привязки определеного компонента к пределенному адресу). 
...скорее всего я не все тут указал)

Вывод: 
1. Мне не понравилась работа с библиотекой MaterialUI. Мало гибкости в изменении готовых компонентов. 
2. После создания этого приложения начал задумываться о правильной организации файлов в моём приложении. 
3. По итогу я начал понимать как работает создание web-application на всех уровнях. Это очень мне помогло в дальнейшем при работе с backend-разработчиками.
4. Понял, что необходимо каждому заниматься своей работой, а не писать приложение соло. Качественнее работа получается в команде. 
5. Ну и конечно я узнал много нового и прокачал свои Hard skills. 


